# 动力节点

## 用户登录

mysql -u root -p 



## MYSQL命令



### 1.查看数据库

show databases;

### 2.创建数据库 （name为数据库名字）

create database   name;

### 3.使用数据库（name为数据库名字）

use name

### 4.查看当前数据库中有哪些表

 show tables;

查看其它库中的表

show tables from 库名;

### 5.初始化数据

source  + 拖动.sql脚本文件到命令窗口   

### 6.删除数据库（name为数据库名字）

drop database name;

### 7.查看表结构

desc  + 表名;

### 8.查看表中的数据

select * from 表名;



### 9.显示当前使用的数据库

### 数据库

select database();  

### 版本号 

select version();

### 10.退出数据库

exit;



### 11.退出一条语句  

**\c**

### 12.查看创建这个表时的语句

show create table 表名 ;



### 13.修改表的名字



alter table 表名 rename 新表名;

























## SQL语句

### 1.语句功能分类

![image-20201105112126221](F:\图像\typora图像保存位置\image-20201105112126221.png)



### 2.简单的查询语句

语法格式：

​			select   字段名1, ...    ....from 表名; 	 （**注意： 最后一个字段名 与from之间 只空一个空格 **）  

​			select  * from 表名;  显示所有字段

**字段可以参与数学运算 ： 例如查询工资 计算年薪**

  		select   字段名（工资） *  12  from   表名;

**给查询后的段名重命名**

select     字段名   as（as用来给前面的字段重新命名为后面的名字，）   新字段名    from  表名；

注：as 关键字可以省略。

如果想要把 新字段名 设置成中文， 请加上 ' '  双单引号  把字段名 引起来

**例**：select    bsbsddsf   as   '新字段名'    from  表名；

**条件查询**

![image-20201105232937779](F:\图像\typora图像保存位置\image-20201105232937779.png)

![image-20201106000554576](F:\图像\typora图像保存位置\image-20201106000554576.png)







提示：

 	1.任何一条sql语句一“ ; ”结尾
 	
 	2.sql语句不区分大小写。



### 3.查询条件

![image-20201106124639716](F:\图像\typora图像保存位置\image-20201106124639716.png)



and 比 or  的优先级高

![image-20201106132122188](F:\图像\typora图像保存位置\image-20201106132122188.png)



### 4.排序

select  字段名   from 表名   order by  字段名  , 字段名 ...

​                                               前面的字段 优先级更高



### 5.分组函数

![image-20201106145258613](F:\图像\typora图像保存位置\image-20201106145258613.png)

单行处理函数

![image-20201106151842180](F:\图像\typora图像保存位置\image-20201106151842180.png)

![image-20201106151937538](F:\图像\typora图像保存位置\image-20201106151937538.png)



**分组函数自动忽略NULL**



### 6.分组查询



![image-20201106204933206](F:\图像\typora图像保存位置\image-20201106204933206.png)

 分组函数一般都会和 group by 联合使用

并且 每一个分组函数都是在 group by执行 结束过后才会执行



如果一条语句中没有 group by 那么整张表的数据会自动归为一组。  使用group by 可以将表内的数据 分成好几组。



分组函数之所以不能在 where后面 ，  是因为 group by 在 where执行后才会执行。

**顺序图 ↓ ：**

![image-20201106210519518](F:\图像\typora图像保存位置\image-20201106210519518.png)



当 group by 参加分组的时候  ， select 只能正确显示 参加分组的字段，没有参加分组的字段 显示的无意义的值。

 

![image-20201106221723495](F:\图像\typora图像保存位置\image-20201106221723495.png)



![image-20201106222245800](F:\图像\typora图像保存位置\image-20201106222245800.png)

上面 那一行 效率太低 ，  既然2900迟早也要丢掉 ， 可以用where语句   因为group by 比where晚执行 ， 这样可以节省不必要的步骤。



### 7.DQL语句顺序

select       5           显示

​		........

from 		1			来自那个表

​		.......	

where        2			限制 ， （一次过滤）

​		......	

group by	 3			分组函数

​		......	

having 		4			二次过滤（不要乱用，效率低）

​		.....

order by		6		排序

​			......

### 去重：

![image-20201109124923352](F:\图像\typora图像保存位置\image-20201109124923352.png)

















## 查询

### 笛卡尔积现象：

找出每一个员工的部门名称，要求显示员工名和部门名。

select  ename ,dname from emp,dept;

![image-20201109165806904](F:\图像\typora图像保存位置\image-20201109165806904.png)

 最后运行出来的结果为 56条，   一共十四条员工信息 ，每一个员工 又都会与 部门信息相结合。      

这种现象为 笛卡尔乘积现象。    如果两张表进行连接查询没有加以条件限制的话，查询结果为两张表的乘积。



### 查询连接：





#### 内连接：  

​		**等值连接：**

![image-20201109175058405](F:\图像\typora图像保存位置\image-20201109175058405.png)

select 

​		e.name,d.dname

from

​		emp e

inner(可省略但是带着更好， inner是内的意思 能看出来是内连接还是外连接)  join

​		dept d

on

​		e.deptno = d.deptno;





​		**非等值连接**



![image-20201109191607548](F:\图像\typora图像保存位置\image-20201109191607548.png)

join 里面是  联合的表

 on 是限制条件。





​		**自连接**

​					一张表看做两张表 ，自己连接自己



​				成功的例子

![image-20201109194428475](F:\图像\typora图像保存位置\image-20201109194428475.png)

​		自己根据理解敲得对比一下哈哈哈哈哈  你这个笨比炸毛 笑死我了。

​					![image-20201109194506904](F:\图像\typora图像保存位置\image-20201109194506904.png)







#### 外连接：

**一些概念：**

![image-20201110102706635](F:\图像\typora图像保存位置\image-20201110102706635.png)

左外连接表示左边的这张表示主表：

右外连接表示右边的这张表示主表；

 每个左连接都有右连接的写法，右连接也会有对应的左连接的写法。



​		**左外连接（右外连接）：**

select   字段，字段

from   表名  

 left（right）*outer*  join     表名

on    条件 ;



外连接最重要的特点是：主表的数据无条件的全部查询出来。





练习题 ：查询哪个部门没有员工；

我写的

![image-20201110110320490](F:\图像\typora图像保存位置\image-20201110110320490.png)

​	老师写的：（**QAQ 我还以为我自己做对了呢 我是笨比**）

![image-20201110110615602](F:\图像\typora图像保存位置\image-20201110110615602.png)





#### 全连接：



### 子查询

where嵌套子查询：



![image-20201106211820126](F:\图像\typora图像保存位置\image-20201106211820126.png)





from嵌套子查询

​     案例：

   找出每个部门平均水平的薪资等级

![image-20201111124816449](F:\图像\typora图像保存位置\image-20201111124816449.png)

   from 里面嵌套子循环， 写的select语句 最后面 一定要加 group by  把查询结果做成一张新表。 否则就是错误的。       

​     只要理解了这一步逻辑  就可以了  把做成的新表当做一场初始表，来继续进行你的SQL语句就行了。

select  t.*,s.grade from  (select deptno,avg(sal) as avgsal from emp group by deptno) t join salgrade s on  t.avgsal between s.losal and s.hisal;



案例：

![image-20201111130841018](F:\图像\typora图像保存位置\image-20201111130841018.png)

  这个案例不用进行子查询也可以实行

![image-20201111131447569](F:\图像\typora图像保存位置\image-20201111131447569.png)





select子查询：（不常用）

![image-20201111132306222](F:\图像\typora图像保存位置\image-20201111132306222.png)





### union

作用： 将两张表的查询内容相加

![image-20201111133506012](F:\图像\typora图像保存位置\image-20201111133506012.png)





### limit以及通用分页SQL

![image-20201111172250763](F:\图像\typora图像保存位置\image-20201111172250763.png)

分页公式

![image-20201111172327681](F:\图像\typora图像保存位置\image-20201111172327681.png)

























## 建表

### 数据库中的数据类型

![image-20201111173420114](F:\图像\typora图像保存位置\image-20201111173420114.png)

BLOB文件一般储存在硬盘里，  把文件路径存储在数据库中 ，否则会造成数据库中大量内存的浪费

### 创建表

![image-20201111173507751](F:\图像\typora图像保存位置\image-20201111173507751.png)

数据库中创建表的表名一般以  t_或者

tbl_开头

 

### 向表中插入数据

字段3 值 没有输入简体中文 ，因为命令行窗口中的编码格式为gbk，而编译器中的编码格式为utf—8 ，  格式不匹配会导致乱码的出现。

![image-20201111200516800](F:\图像\typora图像保存位置\image-20201111200516800.png)



表名后面的字段名可以省略 但是， values（）里面的数据 必须按照字段顺序，正确的赋值。

![image-20201111202853160](F:\图像\typora图像保存位置\image-20201111202853160.png)

顾名思义 ，一次性插入多行数据的写法



### 表的复制&将查询到的数据插入到表中。

![image-20201111203340725](F:\图像\typora图像保存位置\image-20201111203340725.png)



### 表中数据的修改

![image-20201111203817532](F:\图像\typora图像保存位置\image-20201111203817532.png)

切记不要将字段中间的 “ ， ”号   写成 and  。   

**注！！！：** 切记   一定要加where条件 否则 数据表中的数据将全部更新。









### 删库

![image-20201111204544033](F:\图像\typora图像保存位置\image-20201111204544033.png)



**注意 不加where条件加以限制的话 ，就删库了。（滑稽）。**

![image-20201111205152284](F:\图像\typora图像保存位置\image-20201111205152284.png)

其实上面这个才是删库 ， 。 delete删除的数据可以恢复。

## 约束



### 添加约束语法

![image-20201112104322023](F:\图像\typora图像保存位置\image-20201112104322023.png)



```sql
/*非空约束*/
ALTER TABLE 表名
modify 字段名 字段属性
NOT NULL;
/*主键约束*/
ALTER TABLE 表名
ADD PRIMARY KEY(要设置);
```







### **唯一性约束： 约束字段可以为：NULL**

![image-20201112112605548](F:\图像\typora图像保存位置\image-20201112112605548.png)

一般的 我们称上图情况为， **【表级约束】**

not null 没有表级约束， 只有列级约束。



### **主键性约束：**

 内容既不能为NULL，也不能重复。

专业术语：  主键约束、主键字段、主键值



主键约束的作用：

只要主键值不同 ，我们就可以认为这是两行不同的数据 ，即使除了主键值1之外的其他值都一样。

### **主键的分类、**

![image-20201112124347989](F:\图像\typora图像保存位置\image-20201112124347989.png)

**auto_increment**该字段 给主键设置一个自增变量1  ， 每次递增1.

### 外键约束

![image-20201112191819563](F:\图像\typora图像保存位置\image-20201112191819563.png)



![image-20201112191854644](F:\图像\typora图像保存位置\image-20201112191854644.png)



![image-20201112191902092](F:\图像\typora图像保存位置\image-20201112191902092.png)

外键值可以为NULL

t_student 没有加主键约束 ，不合法 自己记 笔记 记得加上









## 搜索引擎



![image-20201112192823757](F:\图像\typora图像保存位置\image-20201112192823757.png)

查询当前数据库版本，有哪些搜索引擎可以用。  

show engines



![image-20201113200937676](F:\图像\typora图像保存位置\image-20201113200937676.png)



![image-20201113201713221](F:\图像\typora图像保存位置\image-20201113201713221.png)



## 事务

![image-20201114110858630](F:\图像\typora图像保存位置\image-20201114110858630.png)

![image-20201114110911674](F:\图像\typora图像保存位置\image-20201114110911674.png)

### 事务的四大特性：

![image-20201114111613013](F:\图像\typora图像保存位置\image-20201114111613013.png)



### 事务是默认提交的：

![image-20201117152437255](F:\图像\typora图像保存位置\image-20201117152437255.png)







```sql

BEGIN 或 START TRANSACTION 显式地开启一个事务；

COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；

ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；

SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；

RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；

ROLLBACK TO identifier 把事务回滚到标记点；

SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

MYSQL 事务处理主要有两种方法：
1、用 BEGIN, ROLLBACK, COMMIT来实现

BEGIN 开始一个事务
ROLLBACK 事务回滚
COMMIT 事务确认
2、直接用 SET 来改变 MySQL 的自动提交模式:

SET AUTOCOMMIT=0 禁止自动提交
SET AUTOCOMMIT=1 开启自动提交
```

















## 视图,

语法

```apl
create view 视图名 
as 查询语句
```



视图就是针对某个表创建便利查询的视图, 这样我们每次想要查看这些内容时就不必在编写过长的sql语句了.



视图和表是相对应得, 你的视图是基于那张表创建的,  你修改这张表的数据时,视图中的数据同样会更新,   修改视图中的数据时,对应表中的数据一样会被修改.

总之,在这里我把视图理解为   针对某张表创建的快捷方式.

摘自 **知乎**

（2）修改限制

- 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。
- 在定义数据库对象时，不能不加选择地来定义视图，应该权衡视图的优点和缺点，合理地定义视图。
- 对视图的修改：（1）单表视图操作: 可以进行增删改, 但是要实现新增: 前提是视图必须包含基表的所有不能为空的字段。（2）多表视图(基表来源两个以上)不能插入数据, 也不能删除数据，但是可以修改数据。

使用视图还是有很多局限性的，并没有像直接使用表那么方便。如果视图定义中包含了group by、union、聚合函数以及其他一些特殊情况，就不能被更新了；更新视图的查询也可以是一个关联语句，但是被更新的列必须来自同一张表；而且所有使用临时表算法实现的视图都无法被更新。











































































































































































































































# Frank



## 创建data文件夹

1.使用管理员身份打开命令行窗口。 

2.进入数据库所在的文件夹路径。

3.输入命令mysqld --initialize-insecure --user=root（



# 数据库设计思维

## 数据类型

数据类型的定义没有明确的标准

但是我们应该给某个字段定义什么样的类型 ,是根据我们的业务逻辑来设计的.  

主键一定要用int吗   性别一定要用bool吗  不一定,我们的业务逻辑是怎样的, 我们就定义成什么样. 

