# javaweb

## 超市订单管理系统(bug以弃)

### 项目结构

![image-20210904003952357](F:\图像\typora图像保存位置\image-20210904003952357.png)

在项目中 我们需要有那种  代表着某一具体实体的 抽象类来实例化现实中的对象。   这个pojo包中就存放着这样的抽象类代码。

### 环境搭建

```java
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306?useUnicode=true?characterEncoding=utf-8
username=root
password=123456
//这是mysql连接的配置文件   jdbc懂得都懂   文件名为  db.properties
```





### bug说明已及我学到了什么

bug就是 通过servlet我无法与mysql建立链接, 三天了也没搞懂到底是什么原因, 在网络上搜索了大量的解决方案均无法解决我的问题.无奈之下只好放弃我完成了一部分的项目练习, 第一次web项目以失败告终.  

这个bug他很操蛋,编写的测试单元类就能完好的运行并且获取我想要的数据, 就是一跟这个servlet沾边就无法建立链接, 哪怕把sql语句写死了也无法建立链接. getconnation() 这个方法会一直抛异常.  提示我没有 mysql驱动,  将jar包放入tomcat/lib下还是不行, 还有什么改ip啦 配置环境变量啦, 换jar包版本,换tomcat版本就差没换mysql版本了.



第一次接触项目,尽管只是一个很落后而且不成熟也没什么技术的甚至可以说是demo的练习.  但我从中开始学到了很多,首先就是这个多层架构,  我们编写底层基类, 由最先的 关于获取链接的  DaoBase 类    到 关于对应的实体对象的dao类,     ==并且在这里面我还学到了面向接口的思想,用接口来约束方法.使代码结构变得更清晰,虽然文件看起来多了,但是仔细一分析结构立马就出来了.我觉得这是对我今后的学涯中很有帮助的一点.==      

编写了数据操纵的基类, 我们就要编写 实例对象 的操作类(也就是业务层中),  每一个实例对象  其实都是有一个线性的逻辑在里面的,  例如用户(User)  Userdao调用DaoBase,来完成最基础的底层逻辑调用,  然后我们在这个类里面编写 sql语句,以及 ==sql预编译==,==返回结果集== 等对象的调用以及关闭.  查询到的 User实例化对象, 也是在这一层给new出来的.         

业务层(servic) 也会有一个 处理User实例化对象的类,  这个类作为 底层的数据层 与 上层的servlet层的中间层  ,起到一个数据传输的作用.  将上层中传下来的 用户数据(用户名密码) 传输给底层的数据层,  数据层根据条件生成实例对象,再由业务层返回给servlet层.    这里有一点值得深思 就是既然起到的只是一个传递作用, 那么我不传递不可以么?我直接把用户数据 由servlet传给数据层不行么,还减少了一些步骤.    但是要知道我们这只是个结构简单的小demo很多 难以解决的问题我们在这里不会去刻意的去写那些类.  但是一个成熟的项目,这些东西是必不可少的, 你要把这些代码全都放进serlvlet中吗, 这可能会导致你的一个servlet中有成千上万行代码 ,这样还有什么意思呢 Java开发守则忘了吗?        所以为了结构清晰,便于维护,这个中间层是必须的,(上课的老师讲到, 以后在公司大多数都是在编写业务代码,除非是开发人员,否则一般情况下是接触不到底层的.所以这一层对我们学生来说就更重要了. )

servlet层,这一层就没什么好说的了, 接受浏览器中 ,用户输入的数据,并将数据传输下去, 我们的数据库链接 其实是在这一层创建的,因为如果把链接放在底层,那么频繁的创建与关闭会消耗大量资源, 一个用户在使用网站时,每一次点击可能都是一次查询,一个用户使用网站几十分钟可能会查询几十次, 这才只是一个用户了, 所以我们将数据库链接放在这一层,以便我们根据网站的流量 来做出最合适的调整(为什么不敢说的在准确一点,因为这一层我出了bug这一切也只是我的臆想而已,甚至可能是错误的,以后修为高深了会回来纠正.)    剩下的也没啥好说的了,获取业务层传递上来的数据 ,将这些数据转发到对应的jsp(或者别的?貌似jsp很糟糕,快被淘汰了?)  这一点我觉得不用多说了,但凡多谢点servlet练手 都会对这玩意儿无比熟悉.  



上面三大段就是  关于User 这一个实例对象的 一条逻辑线.  但是我们不可能只有这么一个实例对象,  我们会有更多,  每一个实例对象,在这些层当中都会有至少一个属于自己的类, 实例对象越多 我们每一层中的类也就越多.   一般的,数据库中的一张表就对应着一个实例对象.  所以越是用户群体庞大,业务繁多的项目, 其工程量,类文件数,代码量也就越大. 在我刚入学时,听到前辈们吹牛逼说 一个真正的项目至少是要有几万个代码文件的, 现在我一点也不觉得夸张,因为仅仅是这样一个毫无价值的学习项目,就有上百个代码文件了.

那么关于 util 这个包呢 我也是终于有了一点理解,  因为逻辑链过多,  而这些逻辑链里面除了某些特别的点外,还会有很多共同点,  关于这些点的数据处理我们肯定是需要一些代码的,    util包里面就是存放这些  包含了可以处理这些共同点的方法  的类,因为那么多逻辑链,每一个代码文件里都出现一模一样的代码的话,那这个项目就太失败了,   开发手册中也提到, 如果我们需要大量的用到重复的代码,那么我们应该为他编写一个类.      这样就可以简化核心文件的代码, 使结构更加清晰, 便于以后找bug维护. 

有一说一啊,这个大bug也是我一点一点在各种层中 用了各种测试代码一点一点测试出来的, 错误我甚至可以精确到 一个方法,一个代码块,一个变量.       如果不是这个练习项目的结构够清晰而我也没有偷懒,我是绝对不可能在一个小时之内精准的找到这个bug的. 因为他不报错,只是达不到我想要的结果.     而这时我才编写了十个左右的java文件,每个文件代码也在百行左右.    所以==**利于维护**==绝对比想象中的更重要.(就是这个bug几天了也没能力解决.唉,我是很喜欢这个项目的,只能放弃了.)



