

# 前情提要

本笔记记录的是 本人 学到这个知识时,  即时根据自己的理解所做的笔记,  跟正确答案可能有误差.    当我本人在以后学习中如果发现了错误可能会回来更改.还请不要对这篇笔记抱有信心.   **只是为了加深印象随手做的笔记**. **不具有权威性**





# Ubuntu安装

![image-20210322161548243](F:\图像\typora图像保存位置\image-20210322161548243.png)



![image-20210322161707474](F:\图像\typora图像保存位置\image-20210322161707474.png)



如果在安装系统时 进行了跳过  请进行以下操作

![image-20210507164802360](F:\图像\typora图像保存位置\image-20210507164802360.png)

## 安装VMTOOLS

```
tar zxvf xxxxxxxxxx  //解压 tar压缩包
然后进入该文件夹 执行vmware-install.pl
用sudo  ./命令
```







# 系统变量

## 描述

当我们定义一个系统变量时,   我们会给这个变量附一个值,  也就是一个文件路径

付完之后 我们就可以便捷的使用这个变量,  这个变量就等于我们赋的那个值. 

例如 

```
HOME=/home/zhamao
```

当我使用 cd $HOME时 也等于  cd /home/zhamao

## 用户变量

用户变量也就是局部变量,  只有在这个用户下才能使用.   但这是相对于系统变量而言.  

实际上在linux中我们还可以在shell中定义一个用户局部变量   

语法

```shell
变量名="变量值"
```

但是这个变量 只能在此shell进程中使用, 哪怕是它的子shell也不能使用该变量.



**那么如何定义全局用户变量呢**

```shell
export 变量名="变量值"
unset 变量名             删除定义变量
```

不过呢 全局的用户变量也仅仅只限制与你的这次定义.  

一旦你把shell给关了  那么你定义的用户变量也就被删除了. 







## 规范

注意: 我么所定义的 局部变量  一定是要用小写的.    因为系统变量全是字母都是大写.  所以局部的都要小写来表示,并且单词与单词之间要用下划线隔开.

例如

```
系统变量
HOME=/home/zhamao
局部变量
my_home=/home/zhamao
```



# Linux基础知识





## 文件格式

当我们用ll查看目录时 我们会发现最前面有一行这么个玩意

![image-20210518202246239](F:\图像\typora图像保存位置\image-20210518202246239.png)

这些东西代表着什么意思呢    第一个字母为一组,后面每三个字母为一组. 表示着一段信息

| d rwx r-x --x | 含义                 |
| ------------- | -------------------- |
| d             | 文件格式             |
| rwx           | 组创建文件的人的权限 |
| r-x           | 组内其他成员的权限   |
| --x           | 其他组成员的权限     |



| 开头      | 含义     |
| --------- | -------- |
| d         | 文件目录 |
| -         | 文件     |
| L(是小写) | 链接文件 |



| 第一组 | 含义     |
| ------ | -------- |
| r      | 可以读   |
| w      | 可以写   |
| x      | 可以执行 |

### 文件权限

chmod命令设置文件权限. 

语法 

```shell
chmod 777 文件名
第一个数字是 第一组 rwx
后面同理
```



![image-20210518214507246](F:\图像\typora图像保存位置\image-20210518214507246.png)





## PMS包管理系统

PMS 全称为  package  management system

通俗一点 我们可以把这个系统理解为 安卓的应用商店

这个系统的主要功能就是 软件的下载,更新,卸载.  

不同的Linux发行版,他们的 PMS也不同.

为什么会出现这个系统呢?

```
因为在早期Linux中 安装软件太麻烦了,并且不同的Linux版本,软件适应性也不一样. 有的软件可能在别的Linux中就运行不了.
而且软件的下载与管理也颇为麻烦, 所以PMS应运而生.
```





## 安装软件

那么在Ubuntu中呢有以下几条命令用来安装软件.

```
1. aptitude   :老一辈儿人用的(Frank), 貌似是可以清晰的看到安装过程??  反正现在以及没人维护和使用了 ,在Ubuntu20.04中更是直接把这条命令直接从系统中删除了.

		aptitude命令 与apt-get命令一样，都是Debian Linux及其衍生系统中功能极其强大的包管理工具。与apt-get不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。它通过文本操作菜单和命令两种方式管理软件包。

2.apt-get:  apt-get命令 是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。

3.apt install:	apt 命令是一个功能强大的命令行工具，它不仅可以更新软件包列表索引、执行安装新软件包、升级现有软件包，还能够升级整个 Ubuntu 系统(apt 是 Debian 系操作系统的包管理工具)。与更专业的 APT(Advanced Packaging Tool) 工具 apt-get 和 apt-cache 相比，apt 具有一些更适合交互式场景的选项，它更倾向于成为面向最终用户的工具(而不仅仅是系统管理员)。换句话说，apt 比 apt-get 用起来更简单，用户体验更好。
```





## 文件路径

  '.' :    . 的意思就是 当前路径下的 当前文件夹  例如

  现在我在  "C:\Users\炸毛\AppData\Roaming\Microsoft\Windows\"  路径下, 我要去"C:\Users\炸毛\AppData\Roaming\Microsoft\Windows\Start Menu\Programs"这个文件夹下   那么 我可以在命令中这样写

     ```shell
     cd .\StartMenu\Programs     
         "."=="C:\Users\炸毛\AppData\Roaming\Microsoft\Windows" 
     ```



## 命令行窗口知识

当我们打开命令行窗口时显示的第一行 代码的意思为

```shell
zhamao@zhamao-virtual-machine:~$ 
用户名@计算机名:用户home目录$  
```

## 目录解析

注意:  学习linux系统 必须要超脱 win的系统概念.   不能把win的一些常识运用到linux中.

1. "/" 代表着 文件目录的根目录       linux 没有磁盘
2. "bin目录"   :二进制目录 ,   里面存放着linux的一些工具 , 比如GNU工具  和一些命令.
3. "cdrom": 光盘位置
4. "etc": 配置文件  == win注册表
5. "home": 用户目录
6. "lib": 依赖库文件
7. "mnt":挂载目录 ,  电脑连接的外设 会显示在这个文件夹里面
8. "tmp": 临时目录  存放未保存的临时文件
9. "var": 可变目录  存放日志啥的
10. "boot":  "启动"  启动目录  存放一些启动文件 改动导致开不了机
11. "dev":设备目录
12. "media":媒体目录作用参考mnt目录
13. "opt": 存放第三方软件(类似于D E F盘?)
14. "root": 超级管理员
15. "sbin": 系统二进制目录  ,  比  bin  更高级
16. "srv": 服务目录, 一些服务存在于此
17. "usr": 用户使用的 GNU工具 目录



## 符号链接和硬链接

```
符号链接:创建一个链接文件,该文件 指向目标文件,   可以跨存储介质.
          符号链接 创建的是一个单独的文件.
          用ln -s命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。
		
```

```
硬链接: 创建一个文件副本, 不占用内存大小,  只能在创建在同一个存储介质中
```



## 命令也是一个进程

当你用命令查询一个进程时,往往会查询出来两个,  

![image-20210512205845833](F:\图像\typora图像保存位置\image-20210512205845833.png)

## 挂载

挂载也就是电脑的外来设备  你要给他放置一个地方 ,举个例子  **插/拔U盘**    现在大多数设备都已经实现了自动挂载,但最好还是要学习一下如何挂载设备.  

外来设备的文件 会保存在一个文件区内,   我们的挂载只是将内部文件给映射出去.    

```shell
sudo mount 文件分区  挂载目录
```



## 压缩解压缩

linux只能压缩一个文件  所以当我们要压缩多个文件夹时, 要先用 tar 命令将文件打包,  再用 gzip  压缩文件.



## 父子shell

这里我要更新下我对shell的认识,    shell是软件,   是一个执行命令的平台.     

Ubuntu系统的shell是bash.          当我们打开 终端(我们成这个shell为shell1)   就等于启动了一个 shell进程.    当我们在这个 shell进程中 再次启动一个 shell进程(我们称这个shelll为shell2).     shell2就是shell1 的子shell. 







## 内部命令,外部命令

我们知道   有的时候我们使用命令,会创建一个新的进程,     这种进程就叫做**外部命令** .       例如  ps -f   命令 

ps 命令想要看到 shell当做的 进程   就必须要脱离shell的内部空间 在外部来检测shell,   这种由一个进程 到另一个进程的过程   我们叫做  **衍生**        

当我们在 shell中使用ps后  我们可以检查出以下的进程

![image-20210514161027620](F:\图像\typora图像保存位置\image-20210514161027620.png)







## 后台进程

我们在使用过程中所衍生出的后台进程,在其主进程被杀死时并不会结束运行. 只会丢失它的 PPID (也就是衍生它的进程的PID)    ?????    当我再次实验时 发现好像会自动结束......啊这  到底咋回事.





# linux小技巧

## 查看命令是什么类型

 type[命令]  可以查看这个命令是外部命令还是内部命令.

## 查看曾经用过的命令

history

我么曾经用过得那些命令都存放在,你的用户目录的  .bash_history 文件中   是一个隐藏文件.

这个文件中是有行的, 每一行存放一个你曾经使用过的命令

我们用 !+行号    就可以执行 你执行过的这条命令.



## 使用上一条命令

!!   没错 就是双感叹号





## 一行执行多个命令

命令之间用';'号分隔:   在当前shell下执行    如果给命令加上 '()' 那么括号中的命令就会在一个 自动创建的  **子shell**中执行.   我们可以用下面一条命令 来查询当前的 shell进程数目

```shell
echo $BASH_SUBSHELL
```

  





## 光标移动小技巧

```shell
ctrl + ←/→    '左移/右移 一个单词'
ctrl + l      '清屏'
ctrl + t      '将光标前一个字母 后移一位.'
ctrl + u  	  '将光标前的命令全删除'
ctrl + k      '将光标后的命令全删除'
```

## 便利命令

```
pwd        显示当前文件路径

```





# linux基础命令

## 查询命令

```shell
ls -R  // 递归显示文件
ls -a -l   //详细的显示该目录下的所有文件(包括隐藏文件)  简写为 ll
ls -m  // 显示当前目录的文件以','分隔.

```

## 进入命令

```shell
cd  进入文件目录
cd ..   返回上级目录
```

## 复制命令

```shell
cp '复制文件命令'
cp -R   ./*.文件后缀   文件路径      '将改文件目录下的所有.文件后缀的文件复制到 该路径'
cp -i  '复制后如果有重命名文件 询问是否覆盖'
骚操作 
cp !$      '进入到你上一条命令中的最后一个路径'
```

## 创建命令

```shell
touch 文件名    '创建文件  注意是创建文件哦'
mkdir 文件夹名   '创建文件夹'
mkdir 文件夹名/文件夹名   '递归创建文件夹'
mkdir 文件夹名 文件夹名   '创建多个文件夹'
```

## ln命令

```shell
ln  源文件路径  目标文件路径    '创建硬链接'
ln  -s                        '创建软连接(符号链接)'

```

## mv命令

```shell
mv 要改动的文件   要改的名称   '重命名'
mv 文件   目标文件路径      '移动文件/文件夹'移动之后建议用 cp !$命令						快速移动到目标路径哦

```

## 查看文件

```shell
cat  文件名  -A  将文本中的  回车 制表符打印出来
more 文件名  按页展示文本内容  '空格'向下滚动一页 'b' 向上滚动一页          'Q'退出  '/'
less
tail -n  数字  显示文件末尾几行
head 与上相反

```



## kill

```shell
kill -[信号] [PID]


HUP     1    终端挂断
INT     2    中断（同 Ctrl + C）
QUIT    3    退出（同 Ctrl + \）
KILL    9    强制终止
TERM   15    终止
CONT   18    继续（与STOP相反，fg/bg命令）
STOP   19    暂停（同 Ctrl + Z）
```



## ps命令

```shell
ps -f   查询当前进程和该进程下所有衍生进程 的基本信息.
```



![image-20210512204319332](F:\图像\typora图像保存位置\image-20210512204319332.png)

## mount命令

```shell
mount -o ro                    以只读模式挂载
mount -o rw 				 以可读写模式挂载	
omount    卸载挂载文件
```

## fdisk查询磁盘使用情况和磁盘分区命令

显示磁盘信息      df  -h     '-h 是简化版'

du   查看磁盘使用情况

## 

## sort    将文本内容进行排序 

## 压缩解压缩

```
tar   打包命令
gzip	压缩命令

```



## sleep和jobs 

```shell
sleep  [数字]  顾名思义睡眠多少多少秒
sleep  [数字&] 在后台运行这条命令


jobs -l          查看当前作业  并显示出他的pid  和运行状态
     -p			只显示pid
     -s			只显示处于停止状态的作业
     -r			只显示处于运行状态的作业

```

## 别名

```shell
只是暂时修改

alias 简称='原命令'      就可以设置自己的别名啦  其实就是简化命令
举个例子
alias lll='ls -la'      这样我们就可以用lll代替ls -la了


```



## apt

```bash
apt install          '下载软件'
apt remove			'删除软件'
apt autoremove		 '更彻底的删除'		
apt update			'更新'
apt
```

















# Linux软件

## 实用工具

### thefuck

一个当你输入错误的命令时,自动帮你找到正确命令的软件.   







## 有趣的小软件

### Oneko

在屏幕上出现一个小猫,跟着你的鼠标移动

## sl

小火车

## fortunes-zh

输入fortune会弹出一条中文名言.















# 用户

用户,emmm    cat /etc/passwd    在终端查看本系统的 用户信息

在Linux中所有用户都有一个 UID .    root账户的 uid 就是1

而我们所创建的第一个用户UID通常为1000.

为什么是1000而不是2呢.   

请看下面截图

![image-20210518001826676](F:\图像\typora图像保存位置\image-20210518001826676.png)

透过截图信息我们可以看到, Linux中的用户好像并不想我们所想象的只有两个用户(root,自建用户)那样,   而是有一大堆我们看不懂的用户,  他们的uid都在     1<      >1000 的范围内.   这些用户呢叫叫做  ==**系统用户**== 这些用户 都是Linux上的一些软件所创建的用户.   

## 系统用户思想

我们为什么要使用到 系统用户这个概念呢.   

我们知道你所使用的软件中包含着你的个人信息等等等等,  如果把这些东西的**权限**全部交给 root 来掌握.  那么安全性就太低了.  黑客一旦黑入 root  那么你的电脑就彻底被剥光了,你的所有文件 都将是别人的.   

所以加入一些系统用户就是为了保护这些软件的核心文件.  使得即使黑入root,也不能达到万能.   当然黑入root也是极为不安全的,可不要以为这没什么.





## 用户信息解读

![image-20210518002538564](F:\图像\typora图像保存位置\image-20210518002538564.png)

```c
zhamao     用户名
x          用户密码   linux中 用x来代替显示用户密码. 方便保密.
第一个1000    用户uid
第二个1000    用户组id
最后面的/xxx/xx/xx/xxxx     用户存在路径.   
/*---------------------密码信息解读------------------
:[number]:[number]:[number]:[number]
第一个:[number]               距离上一次修改密码过去了 xxx天
第二个:[number]			  xxx天之后 可以修改密码
第三个:[number]			  xxx天之后 必须修改密码
第四个:[number]			  如果密码要过期,提前xxx天 提醒用户修改密码
第五个:[number]			  密码过期多少天之后 禁用该用户
第六个:[number]			  禁用的时长.
*/
```

那么  我们要如何查看用户密码呢?

我来告诉你    这条命令需要  管理员权限

sudo cat /etc/shadow          

嘿嘿嘿 自己去看吧  .



不得不说 linux的安全做的真到位哈哈哈.

## 添加用户/删除用户

useradd  用户名        添加一个用户

userdle   用户名		删除一个用户



usermod		修改用户配置文件

```
usermod	     目前不会 待学.
passwd 用户名   更改密码   需要sudo
chpasswd < .txt                该命令读取一个文本文件,通过读取文件来给用户设置密码.    
							 文件格式为:	用户名:密码
							 		  	用户名:密码


```



## 扩充知识点

需要课下自己去学习的命令(用户方面哒)

```bash
chsh
chfn
chage
```





















# VIM

## 两种使用模式

普通模式-------操作文件

插入模式-------插入文本.







## VIM操作指令

在记录之前我需要先说明一下, vim的操作指令完全是为了让程序员代打代码的过程中更舒服(右手离开键盘右半区),才实行了这么一套标准.  

不管别人又没有啊,反正本人是深有体会,每次代码写错,总是要把右手离开字母键移动到上下左右那个位置甚至是把右手挪到鼠标上,去拖动选中一些代码.这个过程呢个往往要浪费我几秒时间

非常不爽,可能现在我习惯了,不过这个不爽的情绪是植根在我学习C语言的时期.那是相当那个深刻.    

vim解决了这个问题,所以vim是编译器之神

### **注意vim中所有的快捷键分大小写.**



我们在vim普通模式下最好不要使用 **Backspace**和**delete**因为会牵扯到一些命令,至于哈时候触发我也不知道 Frank没讲

```
/*			光标移动		*/
hjkl               ←↓↑→

ctrl+b			向上翻页
ctrl+f			向下翻页

ctrl+y			向上一行
ctrl+e			向下一行

G				移动到末尾	shift+g 可以输入单个大写
H				移动到开始	gg	也是移动到开始	   

w				下一个单词
b				跳跃单词首字母已经在就跳上一个
e				跳跃单词尾字母已经在就跳下一个

W				下一个单词(以空格间隔)
B				跳跃单词首字母已经在就跳上一个(同上)
E				跳跃单词尾字母已经在就跳下一个(同上)

r				替换光标所在字母并继续使用普通模式
R				一直替换

{				移动到上一段落
}				移动到下一段落

shift+6(^)		跳跃到本行首字母
shift+4($)		跳跃到本行末字母
0			    跳跃到本行开头 包括tap和空格

/*			文本编辑		*/    
i				光标前面插入
a				光标后插入			
o				插入下一行

x				光标所在字符
dd				删除一整行
u				撤销

dw(一起按)		  移除当前光标所在的单词
d+w				删除光标所在字符
d+w+s			在d+w的基础上再删一个字符并进入插入模式

/*			视图模式		*/
p				将缓冲区的内容释放在光标后
yw				复制这个单词到缓冲区
y$				复制这一行从光标直到末尾,到缓冲区
-------上面三兄弟有弊端,复制内容不可视-------
y				复制
o(视图模式)		  调到选中区首部,再按到尾部 
vaw				快速选中单词
vab/B			快速选中单词带"()"/"{}"
va<				快速选中单词带"<>"
v< or >			缩进
v+~				大小写切换
v+u/U			全部转换成小/大写
```



### vim命令

```
:wq				保存退出
:q!				退出不保存
/文本			   查找 n下一个

:s/替换啥/替换成啥/g       范围:本行
:%s/替换啥/替换成啥/g      范围:全文本
:set number		显示行号(临时)
:起始行,末尾行/s././g		替换xx行
:s/替换啥/替换成啥/gc      提示是否替换


i				光标前面插入
a				光标后插入			
o				插入下一行
v				进入视图模式
V				按行选取
ctrl+v			光标纵坐标选取(图一).
```



## VIM骚操作

vim中有一个寄存器,会寄存你删除的内容,  我们可以在任意位置 按   ‘**p** ’ 来释放它.   注意释放位置为  **光标后面**



## 图

### 图一

![image-20210519022106265](F:\图像\typora图像保存位置\image-20210519022106265.png)

